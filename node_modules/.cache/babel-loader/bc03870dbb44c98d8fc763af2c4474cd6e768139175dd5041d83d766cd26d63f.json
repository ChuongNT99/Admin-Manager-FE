{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, mergeRefs, refHandler, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nvar Popover = /** @class */function (_super) {\n  __extends(Popover, _super);\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    _this.popoverElement = null;\n    /** Popover ref handler */\n    _this.popoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n    /**\n     * Target DOM element ref.\n     *\n     * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target\n     * DOM element in order to observe its dimensions.\n     *\n     * @public for testing\n     */\n    _this.targetRef = React.createRef();\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    _this.isMouseInTargetOrPopover = false;\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    _this.lostFocusOnSamePage = true;\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    };\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    _this.isArrowEnabled = function () {\n      var _a, _b;\n      return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n    _this.isHoverInteractionKind = function () {\n      return _this.props.interactionKind === PopoverInteractionKind.HOVER || _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    _this.reposition = function () {\n      var _a;\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n    _this.renderTarget = function (_a) {\n      var _b, _c;\n      var _d, _e;\n      var popperChildRef = _a.ref;\n      var _f = _this.props,\n        children = _f.children,\n        className = _f.className,\n        fill = _f.fill,\n        openOnTargetFocus = _f.openOnTargetFocus,\n        renderTarget = _f.renderTarget;\n      var isOpen = _this.state.isOpen;\n      var isControlled = _this.isControlled();\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n      var targetTagName = _this.props.targetTagName;\n      if (fill) {\n        targetTagName = \"div\";\n      }\n      // react-popper has a wide type for this ref, but we can narrow it based on the source\n      // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17\n      var ref = mergeRefs(popperChildRef, _this.targetRef);\n      var targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onContextMenu: _this.handleTargetContextMenu,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick,\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        onKeyDown: _this.handleKeyDown\n      };\n      // Ensure target is focusable if relevant prop enabled\n      var targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n      var ownTargetProps = __assign({\n        \"aria-haspopup\": (_d = _this.props.popupKind) !== null && _d !== void 0 ? _d : _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY ? undefined : \"true\",\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER_TARGET, (_b = {}, _b[Classes.POPOVER_OPEN] = isOpen,\n        // this class is mainly useful for button targets\n        _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, _b)),\n        ref: ref\n      }, targetEventHandlers);\n      var targetModifierClasses = (_c = {},\n      // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n      // uncontrolled popovers when they are opened by a user interaction\n      _c[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\n      // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n      _c[Classes.FILL] = fill, _c);\n      var target;\n      if (renderTarget !== undefined) {\n        target = renderTarget(__assign(__assign({}, ownTargetProps), {\n          className: classNames(ownTargetProps.className, targetModifierClasses),\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen: isOpen,\n          tabIndex: targetTabIndex\n        }));\n      } else {\n        var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n        if (childTarget === undefined) {\n          return null;\n        }\n        var clonedTarget = React.cloneElement(childTarget, {\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n          tabIndex: (_e = childTarget.props.tabIndex) !== null && _e !== void 0 ? _e : targetTabIndex\n        });\n        var wrappedTarget = React.createElement(targetTagName, __assign(__assign({}, ownTargetProps), _this.props.targetProps), clonedTarget);\n        target = wrappedTarget;\n      }\n      // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can\n      // notify both popper.js and our components about the mounted DOM element.\n      return React.createElement(ResizeSensor, {\n        targetRef: _this.targetRef,\n        onResize: _this.reposition\n      }, target);\n    };\n    _this.renderPopover = function (popperProps) {\n      var _a;\n      var _b;\n      var _c = _this.props,\n        interactionKind = _c.interactionKind,\n        shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose,\n        usePortal = _c.usePortal;\n      var isOpen = _this.state.isOpen;\n      // compute an appropriate transform origin so the scale animation points towards target\n      var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined);\n      // need to update our reference to this function on every render as it will change.\n      _this.popperScheduleUpdate = popperProps.update;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick,\n        // treat ENTER/SPACE keys the same as a click for accessibility\n        onKeyDown: function (event) {\n          return Utils.isKeyboardClick(event) && _this.handlePopoverClick(event);\n        }\n      };\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n      var basePlacement = getBasePlacement(popperProps.placement);\n      var popoverClasses = classNames(Classes.POPOVER, (_a = {}, _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[Classes.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER_MATCH_TARGET_WIDTH] = _this.props.matchTargetWidth, _a[Classes.POPOVER_REFERENCE_HIDDEN] = popperProps.isReferenceHidden === true, _a[Classes.POPOVER_POPPER_ESCAPED] = popperProps.hasPopperEscaped === true, _a), \"\".concat(Classes.POPOVER_CONTENT_PLACEMENT, \"-\").concat(basePlacement), _this.props.popoverClassName);\n      var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;\n      return React.createElement(Overlay, {\n        autoFocus: (_b = _this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n        backdropClassName: Classes.POPOVER_BACKDROP,\n        backdropProps: _this.props.backdropProps,\n        canEscapeKeyClose: _this.props.canEscapeKeyClose,\n        canOutsideClickClose: _this.props.interactionKind === PopoverInteractionKind.CLICK,\n        enforceFocus: _this.props.enforceFocus,\n        hasBackdrop: _this.props.hasBackdrop,\n        isOpen: isOpen,\n        onClose: _this.handleOverlayClose,\n        onClosed: _this.props.onClosed,\n        onClosing: _this.props.onClosing,\n        onOpened: _this.props.onOpened,\n        onOpening: _this.props.onOpening,\n        transitionDuration: _this.props.transitionDuration,\n        transitionName: Classes.POPOVER,\n        usePortal: _this.props.usePortal,\n        portalClassName: _this.props.portalClassName,\n        portalContainer: _this.props.portalContainer,\n        portalStopPropagationEvents: _this.props.portalStopPropagationEvents,\n        // if hover interaction, it doesn't make sense to take over focus control\n        shouldReturnFocusOnClose: _this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n      }, React.createElement(\"div\", {\n        className: Classes.POPOVER_TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(PopoverArrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER_CONTENT\n      }, _this.props.content)))));\n    };\n    _this.handleTargetFocus = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n        _this.handleMouseEnter(e);\n      }\n    };\n    _this.handleTargetBlur = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget != null) {\n          // if the next element to receive focus is within the popover, we'll want to leave the\n          // popover open.\n          if (e.relatedTarget !== _this.popoverElement && !_this.isElementInPopover(e.relatedTarget)) {\n            _this.handleMouseLeave(e);\n          }\n        } else {\n          _this.handleMouseLeave(e);\n        }\n      }\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n    _this.handleTargetContextMenu = function (e) {\n      // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n      // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n      if (e.defaultPrevented) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleMouseEnter = function (e) {\n      _this.isMouseInTargetOrPopover = true;\n      // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n    };\n    _this.handleMouseLeave = function (e) {\n      _this.isMouseInTargetOrPopover = false;\n      // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        }\n        // user-configurable closing delay is helpful when moving mouse from target to popover\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n    };\n    _this.handlePopoverClick = function (e) {\n      var _a, _b, _c;\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var eventPopoverV1 = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();\n      var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false;\n      // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER_DISMISS, \", .\").concat(Classes.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER_DISMISS)) !== null && _c !== void 0 ? _c : false;\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(Classes.DISABLED)) != null;\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleOverlayClose = function (e) {\n      var _a;\n      if (_this.targetRef.current == null || e === undefined) {\n        return;\n      }\n      var event = (_a = e.nativeEvent) !== null && _a !== void 0 ? _a : e;\n      var eventTarget = event.composed ? event.composedPath()[0] : event.target;\n      // if click was in target, target event listener will handle things, so don't close\n      if (!Utils.elementIsOrContains(_this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleKeyDown = function (e) {\n      var isKeyboardClick = Utils.isKeyboardClick(e);\n      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n      if (isKeyboardClick) {\n        _this.handleTargetClick(e);\n      }\n    };\n    _this.handleTargetClick = function (e) {\n      // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n      // see: https://github.com/palantir/blueprint/issues/5775\n      var shouldIgnoreClick = _this.state.isOpen && _this.isSimulatedButtonClick(e);\n      if (!shouldIgnoreClick) {\n        // ensure click did not originate from within inline popover before closing\n        if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n          if (_this.props.isOpen == null) {\n            _this.setState(function (prevState) {\n              return {\n                isOpen: !prevState.isOpen\n              };\n            });\n          } else {\n            _this.setOpenState(!_this.props.isOpen, e);\n          }\n        }\n      }\n    };\n    _this.isSimulatedButtonClick = function (e) {\n      return !e.isTrusted && e.target.matches(\".\".concat(Classes.BUTTON));\n    };\n    return _this;\n  }\n  // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n  // so if we want to look at our actual popover element, we need to reach inside a bit\n  Popover.prototype.getPopoverElement = function () {\n    var _a;\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(Classes.POPOVER));\n  };\n  Popover.prototype.getIsOpen = function (props) {\n    var _a;\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  };\n  Popover.prototype.render = function () {\n    var _a = this.props,\n      disabled = _a.disabled,\n      content = _a.content,\n      placement = _a.placement,\n      _b = _a.position,\n      position = _b === void 0 ? \"auto\" : _b,\n      positioningStrategy = _a.positioningStrategy;\n    var isOpen = this.state.isOpen;\n    var isContentEmpty = content == null || typeof content === \"string\" && content.trim() === \"\";\n    if (isContentEmpty) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n      }\n      // just render the target without a content overlay if there is no content to display\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n    // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode\n    // see https://github.com/floating-ui/react-popper/pull/459\n    return React.createElement(Manager, null, React.createElement(Reference, null, this.renderTarget), React.createElement(Popper, {\n      innerRef: this.popoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      strategy: positioningStrategy,\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover));\n  };\n  Popover.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n  Popover.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen);\n      // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n  Popover.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n    var childrenCount = React.Children.count(props.children);\n    var hasRenderTargetProp = props.renderTarget !== undefined;\n    var hasTargetPropsProp = props.targetProps !== undefined;\n    if (childrenCount === 0 && !hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_REQUIRES_TARGET);\n    }\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n    if (childrenCount > 0 && hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n    if (hasRenderTargetProp && hasTargetPropsProp) {\n      console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n    }\n  };\n  Popover.prototype.getPopperModifiers = function () {\n    var _a, _b, _c, _d;\n    var _e = this.props,\n      matchTargetWidth = _e.matchTargetWidth,\n      modifiers = _e.modifiers,\n      modifiersCustom = _e.modifiersCustom;\n    var popperModifiers = [__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow), __assign(__assign({\n      name: \"computeStyles\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), {\n      options: __assign({\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false\n      }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n    }), __assign(__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"offset\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), {\n      options: __assign({\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2]\n      }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n    }), __assign(__assign({\n      name: \"flip\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n    }), __assign(__assign({\n      name: \"preventOverflow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n    })];\n    if (matchTargetWidth) {\n      popperModifiers.push(matchReferenceWidthModifier);\n    }\n    if (modifiersCustom !== undefined) {\n      popperModifiers.push.apply(popperModifiers, modifiersCustom);\n    }\n    return popperModifiers;\n  };\n  // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n  Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n    var _a, _b, _c, _d, _e;\n    // cancel any existing timeout because we have new state\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n  Popover.prototype.updateDarkParent = function () {\n    var _a;\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = ((_a = this.targetRef.current) === null || _a === void 0 ? void 0 : _a.closest(\".\".concat(Classes.DARK))) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n  Popover.prototype.isElementInPopover = function (element) {\n    var _a, _b;\n    return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n  };\n  Popover.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover\");\n  Popover.defaultProps = {\n    boundary: \"clippingParents\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: PopoverInteractionKind.CLICK,\n    matchTargetWidth: false,\n    minimal: false,\n    openOnTargetFocus: true,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    positioningStrategy: \"absolute\",\n    renderTarget: undefined,\n    shouldReturnFocusOnClose: false,\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true\n  };\n  return Popover;\n}(AbstractPureComponent);\nexport { Popover };\nfunction noop() {\n  // no-op\n}","map":{"version":3,"names":["classNames","React","Manager","Popper","Reference","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","mergeRefs","refHandler","Utils","Errors","Overlay","ResizeSensor","Tooltip","matchReferenceWidthModifier","POPOVER_ARROW_SVG_SIZE","PopoverArrow","positionToPlacement","getBasePlacement","getTransformOrigin","PopoverInteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","Popover","_super","__extends","_this","apply","arguments","state","hasDarkParent","isOpen","getIsOpen","props","popoverElement","popoverRef","targetRef","createRef","isMouseInTargetOrPopover","lostFocusOnSamePage","isControlled","undefined","isArrowEnabled","_a","_b","minimal","modifiers","arrow","enabled","isHoverInteractionKind","interactionKind","reposition","popperScheduleUpdate","call","renderTarget","popperChildRef","ref","_f","children","className","fill","openOnTargetFocus","targetTagName","targetEventHandlers","onBlur","handleTargetBlur","onContextMenu","handleTargetContextMenu","onFocus","handleTargetFocus","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","onClick","handleTargetClick","onKeyDown","handleKeyDown","targetTabIndex","ownTargetProps","__assign","_d","popupKind","POPOVER_TARGET","POPOVER_OPEN","ACTIVE","targetModifierClasses","_c","FILL","target","tabIndex","childTarget","ensureElement","Children","toArray","clonedTarget","cloneElement","disabled","isElementOfType","_e","wrappedTarget","createElement","targetProps","onResize","renderPopover","popperProps","shouldReturnFocusOnClose","usePortal","transformOrigin","placement","arrowProps","style","update","popoverHandlers","handlePopoverClick","event","isKeyboardClick","basePlacement","popoverClasses","POPOVER","DARK","inheritDarkTheme","MINIMAL","POPOVER_CAPTURING_DISMISS","captureDismiss","POPOVER_MATCH_TARGET_WIDTH","matchTargetWidth","POPOVER_REFERENCE_HIDDEN","isReferenceHidden","POPOVER_POPPER_ESCAPED","hasPopperEscaped","concat","POPOVER_CONTENT_PLACEMENT","popoverClassName","defaultAutoFocus","autoFocus","backdropClassName","POPOVER_BACKDROP","backdropProps","canEscapeKeyClose","canOutsideClickClose","enforceFocus","hasBackdrop","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalClassName","portalContainer","portalStopPropagationEvents","POPOVER_TRANSITION_CONTAINER","POPOVER_CONTENT","content","e","relatedTarget","isElementInPopover","defaultPrevented","setOpenState","hoverOpenDelay","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","eventPopoverV1","isEventFromSelf","getPopoverElement","isEventPopoverCapturing","classList","contains","dismissElement","POPOVER_DISMISS","POPOVER_DISMISS_OVERRIDE","shouldDismiss","isDisabled","DISABLED","current","nativeEvent","composed","composedPath","elementIsOrContains","KeyboardEvent","shouldIgnoreClick","isSimulatedButtonClick","setState","prevState","isTrusted","matches","BUTTON","prototype","querySelector","defaultIsOpen","render","position","positioningStrategy","isContentEmpty","trim","isNodeEnv","console","warn","POPOVER_WARN_EMPTY_CONTENT","noop","innerRef","strategy","getPopperModifiers","componentDidMount","updateDarkParent","componentDidUpdate","nextIsOpen","validateProps","onInteraction","POPOVER_WARN_UNCONTROLLED_ONINTERACTION","POPOVER_WARN_HAS_BACKDROP_INLINE","POPOVER_HAS_BACKDROP_INTERACTION","POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","count","hasRenderTargetProp","hasTargetPropsProp","POPOVER_REQUIRES_TARGET","POPOVER_WARN_TOO_MANY_CHILDREN","POPOVER_WARN_DOUBLE_TARGET","POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET","modifiersCustom","popperModifiers","name","computeStyles","options","adaptive","gpuAcceleration","offset","flip","boundary","rootBoundary","preventOverflow","push","timeout","cancelOpenTimeout","element","displayName","defaultProps"],"sources":["D:\\app\\node_modules\\@blueprintjs\\core\\src\\components\\popover\\popover.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { State as PopperState, PositioningStrategy } from \"@popperjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Modifier, Popper, PopperChildrenProps, Reference, ReferenceChildrenProps } from \"react-popper\";\n\nimport {\n    AbstractPureComponent,\n    Classes,\n    DISPLAYNAME_PREFIX,\n    HTMLDivProps,\n    mergeRefs,\n    refHandler,\n    Utils,\n} from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport type {\n    DefaultPopoverTargetHTMLProps,\n    PopoverClickTargetHandlers,\n    PopoverHoverTargetHandlers,\n    PopoverSharedProps,\n} from \"./popoverSharedProps\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nimport type { PopupKind } from \"./popupKind\";\n\nexport const PopoverInteractionKind = {\n    CLICK: \"click\" as \"click\",\n    CLICK_TARGET_ONLY: \"click-target\" as \"click-target\",\n    HOVER: \"hover\" as \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\" as \"hover-target\",\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type PopoverInteractionKind = (typeof PopoverInteractionKind)[keyof typeof PopoverInteractionKind];\n\nexport interface PopoverProps<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps>\n    extends PopoverSharedProps<TProps> {\n    /**\n     * Whether the popover/tooltip should acquire application focus when it first opens.\n     *\n     * @default true for click interactions, false for hover interactions\n     */\n    autoFocus?: boolean;\n\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The content displayed inside the popover.\n     */\n    content?: string | JSX.Element;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default \"click\"\n     */\n    interactionKind?: PopoverInteractionKind;\n\n    /**\n     * The kind of popup displayed by the popover. This property is ignored if\n     * `interactionKind` is {@link PopoverInteractionKind.HOVER_TARGET_ONLY}.\n     * This controls the `aria-haspopup` attribute of the target element. The\n     * default is \"menu\" (technically, `aria-haspopup` will be set to \"true\",\n     * which is the same as \"menu\", for backwards compatibility).\n     *\n     * @default \"menu\" or undefined\n     */\n    popupKind?: PopupKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set to `false` if this is a hover interaction popover.\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Popper.js positioning strategy.\n     *\n     * @see https://popper.js.org/docs/v2/constructors/#strategy\n     * @default \"absolute\"\n     */\n    positioningStrategy?: PositioningStrategy;\n}\n\nexport interface PopoverState {\n    isOpen: boolean;\n    hasDarkParent: boolean;\n}\n\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nexport class Popover<\n    T extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps,\n> extends AbstractPureComponent<PopoverProps<T>, PopoverState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;\n\n    public static defaultProps: PopoverProps = {\n        boundary: \"clippingParents\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        matchTargetWidth: false,\n        minimal: false,\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        positioningStrategy: \"absolute\",\n        renderTarget: undefined,\n        shouldReturnFocusOnClose: false,\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n    };\n\n    public state: PopoverState = {\n        hasDarkParent: false,\n        isOpen: this.getIsOpen(this.props),\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** Popover ref handler */\n    private popoverRef: React.RefCallback<HTMLDivElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    /**\n     * Target DOM element ref.\n     *\n     * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target\n     * DOM element in order to observe its dimensions.\n     *\n     * @public for testing\n     */\n    public targetRef = React.createRef<HTMLElement>();\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => Promise<Partial<PopperState> | null>;\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    private isArrowEnabled = () => !this.props.minimal && this.props.modifiers?.arrow?.enabled !== false;\n\n    private isHoverInteractionKind = () => {\n        return (\n            this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n        );\n    };\n\n    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n    // so if we want to look at our actual popover element, we need to reach inside a bit\n    private getPopoverElement() {\n        return this.popoverElement?.querySelector<HTMLElement>(`.${Classes.POPOVER}`);\n    }\n\n    private getIsOpen(props: PopoverProps<T>) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else {\n            return props.isOpen ?? props.defaultIsOpen!;\n        }\n    }\n\n    public render() {\n        const { disabled, content, placement, position = \"auto\", positioningStrategy } = this.props;\n        const { isOpen } = this.state;\n\n        const isContentEmpty = content == null || (typeof content === \"string\" && content.trim() === \"\");\n        if (isContentEmpty) {\n            // need to do this check in render(), because `isOpen` is derived from\n            // state, and state can't necessarily be accessed in validateProps.\n            if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n                console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n            }\n            // just render the target without a content overlay if there is no content to display\n            return this.renderTarget({ ref: noop });\n        }\n\n        // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode\n        // see https://github.com/floating-ui/react-popper/pull/459\n        return (\n            <Manager>\n                <Reference>{this.renderTarget}</Reference>\n                <Popper\n                    innerRef={this.popoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    strategy={positioningStrategy}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Manager>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    public componentDidUpdate(props: PopoverProps<T>, state: PopoverState) {\n        super.componentDidUpdate(props, state);\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    protected validateProps(props: PopoverProps<T> & { children?: React.ReactNode }) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = React.Children.count(props.children);\n        const hasRenderTargetProp = props.renderTarget !== undefined;\n        const hasTargetPropsProp = props.targetProps !== undefined;\n\n        if (childrenCount === 0 && !hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 1) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (hasRenderTargetProp && hasTargetPropsProp) {\n            console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    private renderTarget = ({ ref: popperChildRef }: ReferenceChildrenProps) => {\n        const { children, className, fill, openOnTargetFocus, renderTarget } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        // react-popper has a wide type for this ref, but we can narrow it based on the source\n        // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17\n        const ref = mergeRefs(popperChildRef as React.RefCallback<HTMLElement>, this.targetRef);\n\n        const targetEventHandlers: PopoverHoverTargetHandlers<T> | PopoverClickTargetHandlers<T> =\n            isHoverInteractionKind\n                ? {\n                      // HOVER handlers\n                      onBlur: this.handleTargetBlur,\n                      onContextMenu: this.handleTargetContextMenu,\n                      onFocus: this.handleTargetFocus,\n                      onMouseEnter: this.handleMouseEnter,\n                      onMouseLeave: this.handleMouseLeave,\n                  }\n                : {\n                      // CLICK needs only one handler\n                      onClick: this.handleTargetClick,\n                      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n                      onKeyDown: this.handleKeyDown,\n                  };\n        // Ensure target is focusable if relevant prop enabled\n        const targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n        const ownTargetProps = {\n            \"aria-haspopup\":\n                this.props.popupKind ??\n                (this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n                    ? undefined\n                    : (\"true\" as \"true\")),\n            // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n            // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n            // applied to the generated target wrapper element.\n            className: classNames(className, Classes.POPOVER_TARGET, {\n                [Classes.POPOVER_OPEN]: isOpen,\n                // this class is mainly useful for button targets\n                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            }),\n            ref,\n            ...targetEventHandlers,\n        };\n\n        const targetModifierClasses = {\n            // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n            // uncontrolled popovers when they are opened by a user interaction\n            [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n            [Classes.FILL]: fill,\n        };\n\n        let target: JSX.Element | undefined;\n\n        if (renderTarget !== undefined) {\n            target = renderTarget({\n                ...ownTargetProps,\n                className: classNames(ownTargetProps.className, targetModifierClasses),\n                // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n                // when *this* popover is open\n                isOpen,\n                tabIndex: targetTabIndex,\n            });\n        } else {\n            const childTarget = Utils.ensureElement(React.Children.toArray(children)[0])!;\n\n            if (childTarget === undefined) {\n                return null;\n            }\n\n            const clonedTarget: JSX.Element = React.cloneElement(childTarget, {\n                className: classNames(childTarget.props.className, targetModifierClasses),\n                // force disable single Tooltip child when popover is open\n                disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n                tabIndex: childTarget.props.tabIndex ?? targetTabIndex,\n            });\n            const wrappedTarget = React.createElement(\n                targetTagName!,\n                {\n                    ...ownTargetProps,\n                    ...this.props.targetProps,\n                },\n                clonedTarget,\n            );\n            target = wrappedTarget;\n        }\n\n        // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can\n        // notify both popper.js and our components about the mounted DOM element.\n        return (\n            <ResizeSensor targetRef={this.targetRef} onResize={this.reposition}>\n                {target}\n            </ResizeSensor>\n        );\n    };\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { interactionKind, shouldReturnFocusOnClose, usePortal } = this.props;\n        const { isOpen } = this.state;\n\n        // compute an appropriate transform origin so the scale animation points towards target\n        const transformOrigin = getTransformOrigin(\n            popperProps.placement,\n            this.isArrowEnabled() ? (popperProps.arrowProps.style as any) : undefined,\n        );\n\n        // need to update our reference to this function on every render as it will change.\n        this.popperScheduleUpdate = popperProps.update;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n            // treat ENTER/SPACE keys the same as a click for accessibility\n            onKeyDown: event => Utils.isKeyboardClick(event) && this.handlePopoverClick(event),\n        };\n        if (\n            interactionKind === PopoverInteractionKind.HOVER ||\n            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const basePlacement = getBasePlacement(popperProps.placement);\n        const popoverClasses = classNames(\n            Classes.POPOVER,\n            {\n                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [Classes.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER_MATCH_TARGET_WIDTH]: this.props.matchTargetWidth,\n                [Classes.POPOVER_REFERENCE_HIDDEN]: popperProps.isReferenceHidden === true,\n                [Classes.POPOVER_POPPER_ESCAPED]: popperProps.hasPopperEscaped === true,\n            },\n            `${Classes.POPOVER_CONTENT_PLACEMENT}-${basePlacement}`,\n            this.props.popoverClassName,\n        );\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n\n        return (\n            <Overlay\n                autoFocus={this.props.autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER_BACKDROP}\n                backdropProps={this.props.backdropProps}\n                canEscapeKeyClose={this.props.canEscapeKeyClose}\n                canOutsideClickClose={this.props.interactionKind === PopoverInteractionKind.CLICK}\n                enforceFocus={this.props.enforceFocus}\n                hasBackdrop={this.props.hasBackdrop}\n                isOpen={isOpen}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER}\n                usePortal={this.props.usePortal}\n                portalClassName={this.props.portalClassName}\n                portalContainer={this.props.portalContainer}\n                portalStopPropagationEvents={this.props.portalStopPropagationEvents}\n                // if hover interaction, it doesn't make sense to take over focus control\n                shouldReturnFocusOnClose={this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose}\n            >\n                <div className={Classes.POPOVER_TRANSITION_CONTAINER} ref={popperProps.ref} style={popperProps.style}>\n                    <ResizeSensor onResize={this.reposition}>\n                        <div\n                            className={popoverClasses}\n                            style={{ transformOrigin }}\n                            ref={this.popoverRef}\n                            {...popoverHandlers}\n                        >\n                            {this.isArrowEnabled() && (\n                                <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                            )}\n                            <div className={Classes.POPOVER_CONTENT}>{this.props.content}</div>\n                        </div>\n                    </ResizeSensor>\n                </div>\n            </Overlay>\n        );\n    };\n\n    private getPopperModifiers(): ReadonlyArray<Modifier<any>> {\n        const { matchTargetWidth, modifiers, modifiersCustom } = this.props;\n        const popperModifiers: Array<Modifier<any>> = [\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"arrow\",\n                ...modifiers?.arrow,\n            },\n            {\n                name: \"computeStyles\",\n                ...modifiers?.computeStyles,\n                options: {\n                    adaptive: true,\n                    // We disable the built-in gpuAcceleration so that\n                    // Popper.js will return us easy to interpolate values\n                    // (top, left instead of transform: translate3d)\n                    // We'll then use these values to generate the needed\n                    // css transform values blended with the react-spring values\n                    gpuAcceleration: false,\n                    ...modifiers?.computeStyles?.options,\n                },\n            },\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"offset\",\n                ...modifiers?.offset,\n                options: {\n                    offset: [0, POPOVER_ARROW_SVG_SIZE / 2],\n                    ...modifiers?.offset?.options,\n                },\n            },\n            {\n                name: \"flip\",\n                ...modifiers?.flip,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.flip?.options,\n                },\n            },\n            {\n                name: \"preventOverflow\",\n                ...modifiers?.preventOverflow,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.preventOverflow?.options,\n                },\n            },\n        ];\n\n        if (matchTargetWidth) {\n            popperModifiers.push(matchReferenceWidthModifier);\n        }\n\n        if (modifiersCustom !== undefined) {\n            popperModifiers.push(...modifiersCustom);\n        }\n\n        return popperModifiers;\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);\n        }\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget != null) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open.\n                if (\n                    e.relatedTarget !== this.popoverElement &&\n                    !this.isElementInPopover(e.relatedTarget as HTMLElement)\n                ) {\n                    this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n                }\n            } else {\n                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    private handleTargetContextMenu = (e: React.MouseEvent<HTMLElement>) => {\n        // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n        // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n        if (e.defaultPrevented) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa).\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n        const eventPopoverV1 = eventTarget.closest(`.${Classes.POPOVER}`);\n        const isEventFromSelf = (eventPopover ?? eventPopoverV1) === this.getPopoverElement();\n\n        const isEventPopoverCapturing =\n            eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            eventPopoverV1?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            false;\n\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n        const shouldDismiss = dismissElement?.classList.contains(Classes.POPOVER_DISMISS) ?? false;\n        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetRef.current == null || e === undefined) {\n            return;\n        }\n\n        const event = (e.nativeEvent ?? e) as Event;\n        const eventTarget = (event.composed ? event.composedPath()[0] : event.target) as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {\n        const isKeyboardClick = Utils.isKeyboardClick(e);\n\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        if (isKeyboardClick) {\n            this.handleTargetClick(e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n        // see: https://github.com/palantir/blueprint/issues/5775\n        const shouldIgnoreClick = this.state.isOpen && this.isSimulatedButtonClick(e);\n        if (!shouldIgnoreClick) {\n            // ensure click did not originate from within inline popover before closing\n            if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n                if (this.props.isOpen == null) {\n                    this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n                } else {\n                    this.setOpenState(!this.props.isOpen, e);\n                }\n            }\n        }\n    };\n\n    private isSimulatedButtonClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        return !e.isTrusted && (e.target as HTMLElement).matches(`.${Classes.BUTTON}`);\n    };\n\n    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(() => this.setOpenState(isOpen, e), timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n            }\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent = this.targetRef.current?.closest(`.${Classes.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.getPopoverElement()?.contains(element) ?? false;\n    }\n}\n\nfunction noop() {\n    // no-op\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,OAAOA,UAAU,MAAM,YAAY;AACnC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,OAAO,EAAYC,MAAM,EAAuBC,SAAS,QAAgC,cAAc;AAEhH,SACIC,qBAAqB,EACrBC,OAAO,EACPC,kBAAkB,EAElBC,SAAS,EACTC,UAAU,EACVC,KAAK,QACF,cAAc;AACrB,OAAO,KAAKC,MAAM,MAAM,qBAAqB;AAC7C,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,YAAY,QAAQ,+BAA+B;AAC5D;AACA,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,2BAA2B,QAAQ,mBAAmB;AAC/D,SAASC,sBAAsB,EAAEC,YAAY,QAAQ,gBAAgB;AACrE,SAASC,mBAAmB,QAAQ,yBAAyB;AAO7D,SAASC,gBAAgB,EAAEC,kBAAkB,QAAQ,eAAe;AAGpE,OAAO,IAAMC,sBAAsB,GAAG;EAClCC,KAAK,EAAE,OAAkB;EACzBC,iBAAiB,EAAE,cAAgC;EACnDC,KAAK,EAAE,OAAkB;EACzBC,iBAAiB,EAAE;CACtB;AA8ED;;;;;;;;AAQA,IAAAC,OAAA,0BAAAC,MAAA;EAEUC,SAAA,CAAAF,OAAA,EAAAC,MAAA;EAFV,SAAAD,QAAA;IAAA,IAAAG,KAAA,GAAAF,MAAA,aAAAA,MAAA,CAAAG,KAAA,OAAAC,SAAA;IA6BWF,KAAA,CAAAG,KAAK,GAAiB;MACzBC,aAAa,EAAE,KAAK;MACpBC,MAAM,EAAEL,KAAI,CAACM,SAAS,CAACN,KAAI,CAACO,KAAK;KACpC;IAED;;;;;;;IAOOP,KAAA,CAAAQ,cAAc,GAAuB,IAAI;IAEhD;IACQR,KAAA,CAAAS,UAAU,GAAsC7B,UAAU,CAACoB,KAAI,EAAE,gBAAgB,EAAEA,KAAI,CAACO,KAAK,CAACE,UAAU,CAAC;IAEjH;;;;;;;;IAQOT,KAAA,CAAAU,SAAS,GAAGtC,KAAK,CAACuC,SAAS,EAAe;IAIjD;IACA;IACQX,KAAA,CAAAY,wBAAwB,GAAG,KAAK;IAExC;IACA;IACQZ,KAAA,CAAAa,mBAAmB,GAAG,IAAI;IAK1Bb,KAAA,CAAAc,YAAY,GAAG;MAAM,OAAAd,KAAI,CAACO,KAAK,CAACF,MAAM,KAAKU,SAAS;IAA/B,CAA+B;IAE5D;IACQf,KAAA,CAAAgB,cAAc,GAAG;MAAA,IAAAC,EAAA,EAAAC,EAAA;MAAM,QAAClB,KAAI,CAACO,KAAK,CAACY,OAAO,IAAI,EAAAD,EAAA,IAAAD,EAAA,GAAAjB,KAAI,CAACO,KAAK,CAACa,SAAS,cAAAH,EAAA,uBAAAA,EAAA,CAAEI,KAAK,cAAAH,EAAA,uBAAAA,EAAA,CAAEI,OAAO,MAAK,KAAK;IAAA;IAE5FtB,KAAA,CAAAuB,sBAAsB,GAAG;MAC7B,OACIvB,KAAI,CAACO,KAAK,CAACiB,eAAe,KAAKhC,sBAAsB,CAACG,KAAK,IAC3DK,KAAI,CAACO,KAAK,CAACiB,eAAe,KAAKhC,sBAAsB,CAACI,iBAAiB;IAE/E,CAAC;IAsGD;;;;;;;;IAQOI,KAAA,CAAAyB,UAAU,GAAG;MAAA,IAAAR,EAAA;MAAM,QAAAA,EAAA,GAAAjB,KAAI,CAAC0B,oBAAoB,cAAAT,EAAA,uBAAAA,EAAA,CAAAU,IAAA,CAAA3B,KAAA,CAAI;IAAA;IAE/CA,KAAA,CAAA4B,YAAY,GAAG,UAACX,EAA+C;;;UAAxCY,cAAc,GAAAZ,EAAA,CAAAa,GAAA;MACnC,IAAAC,EAAA,GAAiE/B,KAAI,CAACO,KAAK;QAAzEyB,QAAQ,GAAAD,EAAA,CAAAC,QAAA;QAAEC,SAAS,GAAAF,EAAA,CAAAE,SAAA;QAAEC,IAAI,GAAAH,EAAA,CAAAG,IAAA;QAAEC,iBAAiB,GAAAJ,EAAA,CAAAI,iBAAA;QAAEP,YAAY,GAAAG,EAAA,CAAAH,YAAe;MACzE,IAAAvB,MAAM,GAAKL,KAAI,CAACG,KAAK,CAAAE,MAAf;MACd,IAAMS,YAAY,GAAGd,KAAI,CAACc,YAAY,EAAE;MACxC,IAAMS,sBAAsB,GAAGvB,KAAI,CAACuB,sBAAsB,EAAE;MAEtD,IAAAa,aAAa,GAAKpC,KAAI,CAACO,KAAK,CAAA6B,aAAf;MACnB,IAAIF,IAAI,EAAE;QACNE,aAAa,GAAG,KAAK;;MAGzB;MACA;MACA,IAAMN,GAAG,GAAGnD,SAAS,CAACkD,cAAgD,EAAE7B,KAAI,CAACU,SAAS,CAAC;MAEvF,IAAM2B,mBAAmB,GACrBd,sBAAsB,GAChB;QACI;QACAe,MAAM,EAAEtC,KAAI,CAACuC,gBAAgB;QAC7BC,aAAa,EAAExC,KAAI,CAACyC,uBAAuB;QAC3CC,OAAO,EAAE1C,KAAI,CAAC2C,iBAAiB;QAC/BC,YAAY,EAAE5C,KAAI,CAAC6C,gBAAgB;QACnCC,YAAY,EAAE9C,KAAI,CAAC+C;OACtB,GACD;QACI;QACAC,OAAO,EAAEhD,KAAI,CAACiD,iBAAiB;QAC/B;QACAC,SAAS,EAAElD,KAAI,CAACmD;OACnB;MACX;MACA,IAAMC,cAAc,GAAGjB,iBAAiB,IAAIZ,sBAAsB,GAAG,CAAC,GAAGR,SAAS;MAClF,IAAMsC,cAAc,GAAAC,QAAA;QAChB,eAAe,EACX,CAAAC,EAAA,GAAAvD,KAAI,CAACO,KAAK,CAACiD,SAAS,cAAAD,EAAA,cAAAA,EAAA,GACnBvD,KAAI,CAACO,KAAK,CAACiB,eAAe,KAAKhC,sBAAsB,CAACI,iBAAiB,GAClEmB,SAAS,GACR,MAAkB;QAC7B;QACA;QACA;QACAkB,SAAS,EAAE9D,UAAU,CAAC8D,SAAS,EAAExD,OAAO,CAACgF,cAAc,GAAAvC,EAAA,OACnDA,EAAA,CAACzC,OAAO,CAACiF,YAAY,IAAGrD,MAAM;QAC9B;QACAa,EAAA,CAACzC,OAAO,CAACkF,MAAM,IAAGtD,MAAM,IAAI,CAACS,YAAY,IAAI,CAACS,sBAAsB,E,IACtE;QACFO,GAAG,EAAAA;MAAA,GACAO,mBAAmB,CACzB;MAED,IAAMuB,qBAAqB,IAAAC,EAAA;MACvB;MACA;MACAA,EAAA,CAACpF,OAAO,CAACkF,MAAM,IAAGtD,MAAM,IAAI,CAACS,YAAY,IAAI,CAACS,sBAAsB;MACpE;MACAsC,EAAA,CAACpF,OAAO,CAACqF,IAAI,IAAG5B,IAAI,E,GACvB;MAED,IAAI6B,MAA+B;MAEnC,IAAInC,YAAY,KAAKb,SAAS,EAAE;QAC5BgD,MAAM,GAAGnC,YAAY,CAAA0B,QAAA,CAAAA,QAAA,KACdD,cAAc;UACjBpB,SAAS,EAAE9D,UAAU,CAACkF,cAAc,CAACpB,SAAS,EAAE2B,qBAAqB,CAAC;UACtE;UACA;UACAvD,MAAM,EAAAA,MAAA;UACN2D,QAAQ,EAAEZ;QAAc,GAC1B;OACL,MAAM;QACH,IAAMa,WAAW,GAAGpF,KAAK,CAACqF,aAAa,CAAC9F,KAAK,CAAC+F,QAAQ,CAACC,OAAO,CAACpC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAE;QAE7E,IAAIiC,WAAW,KAAKlD,SAAS,EAAE;UAC3B,OAAO,IAAI;;QAGf,IAAMsD,YAAY,GAAgBjG,KAAK,CAACkG,YAAY,CAACL,WAAW,EAAE;UAC9DhC,SAAS,EAAE9D,UAAU,CAAC8F,WAAW,CAAC1D,KAAK,CAAC0B,SAAS,EAAE2B,qBAAqB,CAAC;UACzE;UACAW,QAAQ,EAAElE,MAAM,IAAIxB,KAAK,CAAC2F,eAAe,CAACP,WAAW,EAAEhF,OAAO,CAAC,GAAG,IAAI,GAAGgF,WAAW,CAAC1D,KAAK,CAACgE,QAAQ;UACnGP,QAAQ,EAAE,CAAAS,EAAA,GAAAR,WAAW,CAAC1D,KAAK,CAACyD,QAAQ,cAAAS,EAAA,cAAAA,EAAA,GAAIrB;SAC3C,CAAC;QACF,IAAMsB,aAAa,GAAGtG,KAAK,CAACuG,aAAa,CACrCvC,aAAc,EAAAkB,QAAA,CAAAA,QAAA,KAEPD,cAAc,GACdrD,KAAI,CAACO,KAAK,CAACqE,WAAW,GAE7BP,YAAY,CACf;QACDN,MAAM,GAAGW,aAAa;;MAG1B;MACA;MACA,OACItG,KAAA,CAAAuG,aAAA,CAAC3F,YAAY;QAAC0B,SAAS,EAAEV,KAAI,CAACU,SAAS;QAAEmE,QAAQ,EAAE7E,KAAI,CAACyB;MAAU,GAC7DsC,MAAM,CACI;IAEvB,CAAC;IAEO/D,KAAA,CAAA8E,aAAa,GAAG,UAACC,WAAgC;;;MAC/C,IAAAlB,EAAA,GAA2D7D,KAAI,CAACO,KAAK;QAAnEiB,eAAe,GAAAqC,EAAA,CAAArC,eAAA;QAAEwD,wBAAwB,GAAAnB,EAAA,CAAAmB,wBAAA;QAAEC,SAAS,GAAApB,EAAA,CAAAoB,SAAe;MACnE,IAAA5E,MAAM,GAAKL,KAAI,CAACG,KAAK,CAAAE,MAAf;MAEd;MACA,IAAM6E,eAAe,GAAG3F,kBAAkB,CACtCwF,WAAW,CAACI,SAAS,EACrBnF,KAAI,CAACgB,cAAc,EAAE,GAAI+D,WAAW,CAACK,UAAU,CAACC,KAAa,GAAGtE,SAAS,CAC5E;MAED;MACAf,KAAI,CAAC0B,oBAAoB,GAAGqD,WAAW,CAACO,MAAM;MAE9C,IAAMC,eAAe,GAAiB;QAClC;QACAvC,OAAO,EAAEhD,KAAI,CAACwF,kBAAkB;QAChC;QACAtC,SAAS,EAAE,SAAAA,CAAAuC,KAAK;UAAI,OAAA5G,KAAK,CAAC6G,eAAe,CAACD,KAAK,CAAC,IAAIzF,KAAI,CAACwF,kBAAkB,CAACC,KAAK,CAAC;QAA9D;OACvB;MACD,IACIjE,eAAe,KAAKhC,sBAAsB,CAACG,KAAK,IAC/C,CAACsF,SAAS,IAAIzD,eAAe,KAAKhC,sBAAsB,CAACI,iBAAkB,EAC9E;QACE2F,eAAe,CAAC3C,YAAY,GAAG5C,KAAI,CAAC6C,gBAAgB;QACpD0C,eAAe,CAACzC,YAAY,GAAG9C,KAAI,CAAC+C,gBAAgB;;MAGxD,IAAM4C,aAAa,GAAGrG,gBAAgB,CAACyF,WAAW,CAACI,SAAS,CAAC;MAC7D,IAAMS,cAAc,GAAGzH,UAAU,CAC7BM,OAAO,CAACoH,OAAO,GAAA5E,EAAA,OAEXA,EAAA,CAACxC,OAAO,CAACqH,IAAI,IAAG9F,KAAI,CAACO,KAAK,CAACwF,gBAAgB,IAAI/F,KAAI,CAACG,KAAK,CAACC,aAAa,EACvEa,EAAA,CAACxC,OAAO,CAACuH,OAAO,IAAGhG,KAAI,CAACO,KAAK,CAACY,OAAO,EACrCF,EAAA,CAACxC,OAAO,CAACwH,yBAAyB,IAAGjG,KAAI,CAACO,KAAK,CAAC2F,cAAc,EAC9DjF,EAAA,CAACxC,OAAO,CAAC0H,0BAA0B,IAAGnG,KAAI,CAACO,KAAK,CAAC6F,gBAAgB,EACjEnF,EAAA,CAACxC,OAAO,CAAC4H,wBAAwB,IAAGtB,WAAW,CAACuB,iBAAiB,KAAK,IAAI,EAC1ErF,EAAA,CAACxC,OAAO,CAAC8H,sBAAsB,IAAGxB,WAAW,CAACyB,gBAAgB,KAAK,IAAI,E,KAE3E,GAAAC,MAAA,CAAGhI,OAAO,CAACiI,yBAAyB,OAAAD,MAAA,CAAId,aAAa,CAAE,EACvD3F,KAAI,CAACO,KAAK,CAACoG,gBAAgB,CAC9B;MAED,IAAMC,gBAAgB,GAAG5G,KAAI,CAACuB,sBAAsB,EAAE,GAAG,KAAK,GAAGR,SAAS;MAE1E,OACI3C,KAAA,CAAAuG,aAAA,CAAC5F,OAAO;QACJ8H,SAAS,EAAE,CAAA3F,EAAA,GAAAlB,KAAI,CAACO,KAAK,CAACsG,SAAS,cAAA3F,EAAA,cAAAA,EAAA,GAAI0F,gBAAgB;QACnDE,iBAAiB,EAAErI,OAAO,CAACsI,gBAAgB;QAC3CC,aAAa,EAAEhH,KAAI,CAACO,KAAK,CAACyG,aAAa;QACvCC,iBAAiB,EAAEjH,KAAI,CAACO,KAAK,CAAC0G,iBAAiB;QAC/CC,oBAAoB,EAAElH,KAAI,CAACO,KAAK,CAACiB,eAAe,KAAKhC,sBAAsB,CAACC,KAAK;QACjF0H,YAAY,EAAEnH,KAAI,CAACO,KAAK,CAAC4G,YAAY;QACrCC,WAAW,EAAEpH,KAAI,CAACO,KAAK,CAAC6G,WAAW;QACnC/G,MAAM,EAAEA,MAAM;QACdgH,OAAO,EAAErH,KAAI,CAACsH,kBAAkB;QAChCC,QAAQ,EAAEvH,KAAI,CAACO,KAAK,CAACgH,QAAQ;QAC7BC,SAAS,EAAExH,KAAI,CAACO,KAAK,CAACiH,SAAS;QAC/BC,QAAQ,EAAEzH,KAAI,CAACO,KAAK,CAACkH,QAAQ;QAC7BC,SAAS,EAAE1H,KAAI,CAACO,KAAK,CAACmH,SAAS;QAC/BC,kBAAkB,EAAE3H,KAAI,CAACO,KAAK,CAACoH,kBAAkB;QACjDC,cAAc,EAAEnJ,OAAO,CAACoH,OAAO;QAC/BZ,SAAS,EAAEjF,KAAI,CAACO,KAAK,CAAC0E,SAAS;QAC/B4C,eAAe,EAAE7H,KAAI,CAACO,KAAK,CAACsH,eAAe;QAC3CC,eAAe,EAAE9H,KAAI,CAACO,KAAK,CAACuH,eAAe;QAC3CC,2BAA2B,EAAE/H,KAAI,CAACO,KAAK,CAACwH,2BAA2B;QACnE;QACA/C,wBAAwB,EAAEhF,KAAI,CAACuB,sBAAsB,EAAE,GAAG,KAAK,GAAGyD;MAAwB,GAE1F5G,KAAA,CAAAuG,aAAA;QAAK1C,SAAS,EAAExD,OAAO,CAACuJ,4BAA4B;QAAElG,GAAG,EAAEiD,WAAW,CAACjD,GAAG;QAAEuD,KAAK,EAAEN,WAAW,CAACM;MAAK,GAChGjH,KAAA,CAAAuG,aAAA,CAAC3F,YAAY;QAAC6F,QAAQ,EAAE7E,KAAI,CAACyB;MAAU,GACnCrD,KAAA,CAAAuG,aAAA,QAAArB,QAAA;QACIrB,SAAS,EAAE2D,cAAc;QACzBP,KAAK,EAAE;UAAEH,eAAe,EAAAA;QAAA,CAAE;QAC1BpD,GAAG,EAAE9B,KAAI,CAACS;MAAU,GAChB8E,eAAe,GAElBvF,KAAI,CAACgB,cAAc,EAAE,IAClB5C,KAAA,CAAAuG,aAAA,CAACvF,YAAY;QAACgG,UAAU,EAAEL,WAAW,CAACK,UAAU;QAAED,SAAS,EAAEJ,WAAW,CAACI;MAAS,EACrF,EACD/G,KAAA,CAAAuG,aAAA;QAAK1C,SAAS,EAAExD,OAAO,CAACwJ;MAAe,GAAGjI,KAAI,CAACO,KAAK,CAAC2H,OAAO,CAAO,CACjE,CACK,CACb,CACA;IAElB,CAAC;IAgEOlI,KAAA,CAAA2C,iBAAiB,GAAG,UAACwF,CAAgC;MACzD,IAAInI,KAAI,CAACO,KAAK,CAAC4B,iBAAiB,IAAInC,KAAI,CAACuB,sBAAsB,EAAE,EAAE;QAC/D,IAAI4G,CAAC,CAACC,aAAa,IAAI,IAAI,IAAI,CAACpI,KAAI,CAACa,mBAAmB,EAAE;UACtD;UACA;UACA;;QAEJb,KAAI,CAAC6C,gBAAgB,CAACsF,CAA6C,CAAC;;IAE5E,CAAC;IAEOnI,KAAA,CAAAuC,gBAAgB,GAAG,UAAC4F,CAAgC;MACxD,IAAInI,KAAI,CAACO,KAAK,CAAC4B,iBAAiB,IAAInC,KAAI,CAACuB,sBAAsB,EAAE,EAAE;QAC/D,IAAI4G,CAAC,CAACC,aAAa,IAAI,IAAI,EAAE;UACzB;UACA;UACA,IACID,CAAC,CAACC,aAAa,KAAKpI,KAAI,CAACQ,cAAc,IACvC,CAACR,KAAI,CAACqI,kBAAkB,CAACF,CAAC,CAACC,aAA4B,CAAC,EAC1D;YACEpI,KAAI,CAAC+C,gBAAgB,CAACoF,CAA6C,CAAC;;SAE3E,MAAM;UACHnI,KAAI,CAAC+C,gBAAgB,CAACoF,CAA6C,CAAC;;;MAG5EnI,KAAI,CAACa,mBAAmB,GAAGsH,CAAC,CAACC,aAAa,IAAI,IAAI;IACtD,CAAC;IAEOpI,KAAA,CAAAyC,uBAAuB,GAAG,UAAC0F,CAAgC;MAC/D;MACA;MACA,IAAIA,CAAC,CAACG,gBAAgB,EAAE;QACpBtI,KAAI,CAACuI,YAAY,CAAC,KAAK,EAAEJ,CAAC,CAAC;;IAEnC,CAAC;IAEOnI,KAAA,CAAA6C,gBAAgB,GAAG,UAACsF,CAAgC;MACxDnI,KAAI,CAACY,wBAAwB,GAAG,IAAI;MAEpC;MACA;MACA,IACI,CAACZ,KAAI,CAACO,KAAK,CAAC0E,SAAS,IACrBjF,KAAI,CAACqI,kBAAkB,CAACF,CAAC,CAACpE,MAAiB,CAAC,IAC5C/D,KAAI,CAACO,KAAK,CAACiB,eAAe,KAAKhC,sBAAsB,CAACI,iBAAiB,IACvE,CAACI,KAAI,CAACO,KAAK,CAAC4B,iBAAiB,EAC/B;QACEnC,KAAI,CAAC+C,gBAAgB,CAACoF,CAAC,CAAC;OAC3B,MAAM,IAAI,CAACnI,KAAI,CAACO,KAAK,CAACgE,QAAQ,EAAE;QAC7B;QACAvE,KAAI,CAACuI,YAAY,CAAC,IAAI,EAAEJ,CAAC,EAAEnI,KAAI,CAACO,KAAK,CAACiI,cAAc,CAAC;;IAE7D,CAAC;IAEOxI,KAAA,CAAA+C,gBAAgB,GAAG,UAACoF,CAAgC;MACxDnI,KAAI,CAACY,wBAAwB,GAAG,KAAK;MAErC;MACA;MACA;MACAZ,KAAI,CAACyI,UAAU,CAAC;QACZ,IAAIzI,KAAI,CAACY,wBAAwB,EAAE;UAC/B;;QAEJ;QACAZ,KAAI,CAACuI,YAAY,CAAC,KAAK,EAAEJ,CAAC,EAAEnI,KAAI,CAACO,KAAK,CAACmI,eAAe,CAAC;MAC3D,CAAC,CAAC;IACN,CAAC;IAEO1I,KAAA,CAAAwF,kBAAkB,GAAG,UAAC2C,CAAmE;;MAC7F,IAAMQ,WAAW,GAAGR,CAAC,CAACpE,MAAqB;MAC3C,IAAM6E,YAAY,GAAGD,WAAW,CAACE,OAAO,CAAC,IAAApC,MAAA,CAAIhI,OAAO,CAACoH,OAAO,CAAE,CAAC;MAC/D,IAAMiD,cAAc,GAAGH,WAAW,CAACE,OAAO,CAAC,IAAApC,MAAA,CAAIhI,OAAO,CAACoH,OAAO,CAAE,CAAC;MACjE,IAAMkD,eAAe,GAAG,CAACH,YAAY,aAAZA,YAAY,cAAZA,YAAY,GAAIE,cAAc,MAAM9I,KAAI,CAACgJ,iBAAiB,EAAE;MAErF,IAAMC,uBAAuB,GACzB,CAAA/H,EAAA,IAAAD,EAAA,GAAA2H,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEM,SAAS,CAACC,QAAQ,CAAC1K,OAAO,CAACwH,yBAAyB,CAAC,cAAAhF,EAAA,cAAAA,EAAA,GACnE6H,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEI,SAAS,CAACC,QAAQ,CAAC1K,OAAO,CAACwH,yBAAyB,CAAC,cAAA/E,EAAA,cAAAA,EAAA,GACrE,KAAK;MAET;MACA,IAAMkI,cAAc,GAAGT,WAAW,CAACE,OAAO,CAAC,IAAApC,MAAA,CAAIhI,OAAO,CAAC4K,eAAe,SAAA5C,MAAA,CAAMhI,OAAO,CAAC6K,wBAAwB,CAAE,CAAC;MAC/G,IAAMC,aAAa,GAAG,CAAA1F,EAAA,GAAAuF,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEF,SAAS,CAACC,QAAQ,CAAC1K,OAAO,CAAC4K,eAAe,CAAC,cAAAxF,EAAA,cAAAA,EAAA,GAAI,KAAK;MAC1F,IAAM2F,UAAU,GAAGb,WAAW,CAACE,OAAO,CAAC,eAAApC,MAAA,CAAehI,OAAO,CAACgL,QAAQ,CAAE,CAAC,IAAI,IAAI;MAEjF,IAAIF,aAAa,IAAI,CAACC,UAAU,KAAK,CAACP,uBAAuB,IAAIF,eAAe,CAAC,EAAE;QAC/E/I,KAAI,CAACuI,YAAY,CAAC,KAAK,EAAEJ,CAAC,CAAC;;IAEnC,CAAC;IAEOnI,KAAA,CAAAsH,kBAAkB,GAAG,UAACa,CAAqC;;MAC/D,IAAInI,KAAI,CAACU,SAAS,CAACgJ,OAAO,IAAI,IAAI,IAAIvB,CAAC,KAAKpH,SAAS,EAAE;QACnD;;MAGJ,IAAM0E,KAAK,GAAI,CAAAxE,EAAA,GAAAkH,CAAC,CAACwB,WAAW,cAAA1I,EAAA,cAAAA,EAAA,GAAIkH,CAAW;MAC3C,IAAMQ,WAAW,GAAIlD,KAAK,CAACmE,QAAQ,GAAGnE,KAAK,CAACoE,YAAY,EAAE,CAAC,CAAC,CAAC,GAAGpE,KAAK,CAAC1B,MAAsB;MAC5F;MACA,IAAI,CAAClF,KAAK,CAACiL,mBAAmB,CAAC9J,KAAI,CAACU,SAAS,CAACgJ,OAAO,EAAEf,WAAW,CAAC,IAAIR,CAAC,CAACwB,WAAW,YAAYI,aAAa,EAAE;QAC3G/J,KAAI,CAACuI,YAAY,CAAC,KAAK,EAAEJ,CAAC,CAAC;;IAEnC,CAAC;IAEOnI,KAAA,CAAAmD,aAAa,GAAG,UAACgF,CAAmC;MACxD,IAAMzC,eAAe,GAAG7G,KAAK,CAAC6G,eAAe,CAACyC,CAAC,CAAC;MAEhD;MACA,IAAIzC,eAAe,EAAE;QACjB1F,KAAI,CAACiD,iBAAiB,CAACkF,CAAC,CAAC;;IAEjC,CAAC;IAEOnI,KAAA,CAAAiD,iBAAiB,GAAG,UAACkF,CAAmE;MAC5F;MACA;MACA,IAAM6B,iBAAiB,GAAGhK,KAAI,CAACG,KAAK,CAACE,MAAM,IAAIL,KAAI,CAACiK,sBAAsB,CAAC9B,CAAC,CAAC;MAC7E,IAAI,CAAC6B,iBAAiB,EAAE;QACpB;QACA,IAAI,CAAChK,KAAI,CAACO,KAAK,CAACgE,QAAQ,IAAI,CAACvE,KAAI,CAACqI,kBAAkB,CAACF,CAAC,CAACpE,MAAqB,CAAC,EAAE;UAC3E,IAAI/D,KAAI,CAACO,KAAK,CAACF,MAAM,IAAI,IAAI,EAAE;YAC3BL,KAAI,CAACkK,QAAQ,CAAC,UAAAC,SAAS;cAAI,OAAC;gBAAE9J,MAAM,EAAE,CAAC8J,SAAS,CAAC9J;cAAM,CAAE;YAA9B,CAA+B,CAAC;WAC9D,MAAM;YACHL,KAAI,CAACuI,YAAY,CAAC,CAACvI,KAAI,CAACO,KAAK,CAACF,MAAM,EAAE8H,CAAC,CAAC;;;;IAIxD,CAAC;IAEOnI,KAAA,CAAAiK,sBAAsB,GAAG,UAAC9B,CAAmE;MACjG,OAAO,CAACA,CAAC,CAACiC,SAAS,IAAKjC,CAAC,CAACpE,MAAsB,CAACsG,OAAO,CAAC,IAAA5D,MAAA,CAAIhI,OAAO,CAAC6L,MAAM,CAAE,CAAC;IAClF,CAAC;;EAiCL;EA9gBI;EACA;EACQzK,OAAA,CAAA0K,SAAA,CAAAvB,iBAAiB,GAAzB;;IACI,OAAO,CAAA/H,EAAA,OAAI,CAACT,cAAc,cAAAS,EAAA,uBAAAA,EAAA,CAAEuJ,aAAa,CAAc,IAAA/D,MAAA,CAAIhI,OAAO,CAACoH,OAAO,CAAE,CAAC;EACjF,CAAC;EAEOhG,OAAA,CAAA0K,SAAA,CAAAjK,SAAS,GAAjB,UAAkBC,KAAsB;;IACpC;IACA,IAAIA,KAAK,CAACgE,QAAQ,EAAE;MAChB,OAAO,KAAK;KACf,MAAM;MACH,OAAO,CAAAtD,EAAA,GAAAV,KAAK,CAACF,MAAM,cAAAY,EAAA,cAAAA,EAAA,GAAIV,KAAK,CAACkK,aAAc;;EAEnD,CAAC;EAEM5K,OAAA,CAAA0K,SAAA,CAAAG,MAAM,GAAb;IACU,IAAAzJ,EAAA,GAA2E,IAAI,CAACV,KAAK;MAAnFgE,QAAQ,GAAAtD,EAAA,CAAAsD,QAAA;MAAE2D,OAAO,GAAAjH,EAAA,CAAAiH,OAAA;MAAE/C,SAAS,GAAAlE,EAAA,CAAAkE,SAAA;MAAEjE,EAAA,GAAAD,EAAA,CAAA0J,QAAiB;MAAjBA,QAAQ,GAAAzJ,EAAA,cAAG,MAAM,GAAAA,EAAA;MAAE0J,mBAAmB,GAAA3J,EAAA,CAAA2J,mBAAe;IACnF,IAAAvK,MAAM,GAAK,IAAI,CAACF,KAAK,CAAAE,MAAf;IAEd,IAAMwK,cAAc,GAAG3C,OAAO,IAAI,IAAI,IAAK,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAAC4C,IAAI,EAAE,KAAK,EAAG;IAChG,IAAID,cAAc,EAAE;MAChB;MACA;MACA,IAAI,CAACtG,QAAQ,IAAIlE,MAAM,KAAK,KAAK,IAAI,CAACxB,KAAK,CAACkM,SAAS,CAAC,YAAY,CAAC,EAAE;QACjEC,OAAO,CAACC,IAAI,CAACnM,MAAM,CAACoM,0BAA0B,CAAC;;MAEnD;MACA,OAAO,IAAI,CAACtJ,YAAY,CAAC;QAAEE,GAAG,EAAEqJ;MAAI,CAAE,CAAC;;IAG3C;IACA;IACA,OACI/M,KAAA,CAAAuG,aAAA,CAACtG,OAAO,QACJD,KAAA,CAAAuG,aAAA,CAACpG,SAAS,QAAE,IAAI,CAACqD,YAAY,CAAa,EAC1CxD,KAAA,CAAAuG,aAAA,CAACrG,MAAM;MACH8M,QAAQ,EAAE,IAAI,CAAC3K,UAAU;MACzB0E,SAAS,EAAEA,SAAS,aAATA,SAAS,cAATA,SAAS,GAAI9F,mBAAmB,CAACsL,QAAQ,CAAC;MACrDU,QAAQ,EAAET,mBAAmB;MAC7BxJ,SAAS,EAAE,IAAI,CAACkK,kBAAkB;IAAE,GAEnC,IAAI,CAACxG,aAAa,CACd,CACH;EAElB,CAAC;EAEMjF,OAAA,CAAA0K,SAAA,CAAAgB,iBAAiB,GAAxB;IACI,IAAI,CAACC,gBAAgB,EAAE;EAC3B,CAAC;EAEM3L,OAAA,CAAA0K,SAAA,CAAAkB,kBAAkB,GAAzB,UAA0BlL,KAAsB,EAAEJ,KAAmB;IACjEL,MAAA,CAAAyK,SAAA,CAAMkB,kBAAkB,CAAA9J,IAAA,OAACpB,KAAK,EAAEJ,KAAK,CAAC;IACtC,IAAI,CAACqL,gBAAgB,EAAE;IAEvB,IAAME,UAAU,GAAG,IAAI,CAACpL,SAAS,CAAC,IAAI,CAACC,KAAK,CAAC;IAE7C,IAAI,IAAI,CAACA,KAAK,CAACF,MAAM,IAAI,IAAI,IAAIqL,UAAU,KAAK,IAAI,CAACvL,KAAK,CAACE,MAAM,EAAE;MAC/D,IAAI,CAACkI,YAAY,CAACmD,UAAU,CAAC;MAC7B;MACA;MACA,IAAI,CAACxB,QAAQ,CAAC;QAAE7J,MAAM,EAAEqL;MAAU,CAAE,CAAC;KACxC,MAAM,IAAI,IAAI,CAACnL,KAAK,CAACgE,QAAQ,IAAI,IAAI,CAACpE,KAAK,CAACE,MAAM,IAAI,IAAI,CAACE,KAAK,CAACF,MAAM,IAAI,IAAI,EAAE;MAC9E;MACA,IAAI,CAACkI,YAAY,CAAC,KAAK,CAAC;;EAEhC,CAAC;EAES1I,OAAA,CAAA0K,SAAA,CAAAoB,aAAa,GAAvB,UAAwBpL,KAAuD;IAC3E,IAAIA,KAAK,CAACF,MAAM,IAAI,IAAI,IAAIE,KAAK,CAACqL,aAAa,IAAI,IAAI,EAAE;MACrDZ,OAAO,CAACC,IAAI,CAACnM,MAAM,CAAC+M,uCAAuC,CAAC;;IAEhE,IAAItL,KAAK,CAAC6G,WAAW,IAAI,CAAC7G,KAAK,CAAC0E,SAAS,EAAE;MACvC+F,OAAO,CAACC,IAAI,CAACnM,MAAM,CAACgN,gCAAgC,CAAC;;IAEzD,IAAIvL,KAAK,CAAC6G,WAAW,IAAI7G,KAAK,CAACiB,eAAe,KAAKhC,sBAAsB,CAACC,KAAK,EAAE;MAC7EuL,OAAO,CAACC,IAAI,CAACnM,MAAM,CAACiN,gCAAgC,CAAC;;IAEzD,IAAIxL,KAAK,CAAC4E,SAAS,KAAKpE,SAAS,IAAIR,KAAK,CAACoK,QAAQ,KAAK5J,SAAS,EAAE;MAC/DiK,OAAO,CAACC,IAAI,CAACnM,MAAM,CAACkN,yCAAyC,CAAC;;IAGlE,IAAMC,aAAa,GAAG7N,KAAK,CAAC+F,QAAQ,CAAC+H,KAAK,CAAC3L,KAAK,CAACyB,QAAQ,CAAC;IAC1D,IAAMmK,mBAAmB,GAAG5L,KAAK,CAACqB,YAAY,KAAKb,SAAS;IAC5D,IAAMqL,kBAAkB,GAAG7L,KAAK,CAACqE,WAAW,KAAK7D,SAAS;IAE1D,IAAIkL,aAAa,KAAK,CAAC,IAAI,CAACE,mBAAmB,EAAE;MAC7CnB,OAAO,CAACC,IAAI,CAACnM,MAAM,CAACuN,uBAAuB,CAAC;;IAEhD,IAAIJ,aAAa,GAAG,CAAC,EAAE;MACnBjB,OAAO,CAACC,IAAI,CAACnM,MAAM,CAACwN,8BAA8B,CAAC;;IAEvD,IAAIL,aAAa,GAAG,CAAC,IAAIE,mBAAmB,EAAE;MAC1CnB,OAAO,CAACC,IAAI,CAACnM,MAAM,CAACyN,0BAA0B,CAAC;;IAEnD,IAAIJ,mBAAmB,IAAIC,kBAAkB,EAAE;MAC3CpB,OAAO,CAACC,IAAI,CAACnM,MAAM,CAAC0N,4CAA4C,CAAC;;EAEzE,CAAC;EA0MO3M,OAAA,CAAA0K,SAAA,CAAAe,kBAAkB,GAA1B;;IACU,IAAA7G,EAAA,GAAmD,IAAI,CAAClE,KAAK;MAA3D6F,gBAAgB,GAAA3B,EAAA,CAAA2B,gBAAA;MAAEhF,SAAS,GAAAqD,EAAA,CAAArD,SAAA;MAAEqL,eAAe,GAAAhI,EAAA,CAAAgI,eAAe;IACnE,IAAMC,eAAe,GAAyB,C;MAEtCpL,OAAO,EAAE,IAAI,CAACN,cAAc,EAAE;MAC9B2L,IAAI,EAAE;IAAO,GACVvL,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEC,KAAK,G;MAGnBsL,IAAI,EAAE;IAAe,GAClBvL,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEwL,aAAa;MAC3BC,OAAO,EAAAvJ,QAAA;QACHwJ,QAAQ,EAAE,IAAI;QACd;QACA;QACA;QACA;QACA;QACAC,eAAe,EAAE;MAAK,GACnB,CAAA9L,EAAA,GAAAG,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEwL,aAAa,cAAA3L,EAAA,uBAAAA,EAAA,CAAE4L,OAAO;IAAA,I;MAIxCvL,OAAO,EAAE,IAAI,CAACN,cAAc,EAAE;MAC9B2L,IAAI,EAAE;IAAQ,GACXvL,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE4L,MAAM;MACpBH,OAAO,EAAAvJ,QAAA;QACH0J,MAAM,EAAE,CAAC,CAAC,EAAE7N,sBAAsB,GAAG,CAAC;MAAC,GACpC,CAAA+B,EAAA,GAAAE,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE4L,MAAM,cAAA9L,EAAA,uBAAAA,EAAA,CAAE2L,OAAO;IAAA,I;MAIjCF,IAAI,EAAE;IAAM,GACTvL,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE6L,IAAI;MAClBJ,OAAO,EAAAvJ,QAAA;QACH4J,QAAQ,EAAE,IAAI,CAAC3M,KAAK,CAAC2M,QAAQ;QAC7BC,YAAY,EAAE,IAAI,CAAC5M,KAAK,CAAC4M;MAAY,GAClC,CAAAtJ,EAAA,GAAAzC,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE6L,IAAI,cAAApJ,EAAA,uBAAAA,EAAA,CAAEgJ,OAAO;IAAA,I;MAI/BF,IAAI,EAAE;IAAiB,GACpBvL,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEgM,eAAe;MAC7BP,OAAO,EAAAvJ,QAAA;QACH4J,QAAQ,EAAE,IAAI,CAAC3M,KAAK,CAAC2M,QAAQ;QAC7BC,YAAY,EAAE,IAAI,CAAC5M,KAAK,CAAC4M;MAAY,GAClC,CAAA5J,EAAA,GAAAnC,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEgM,eAAe,cAAA7J,EAAA,uBAAAA,EAAA,CAAEsJ,OAAO;IAAA,GAGjD;IAED,IAAIzG,gBAAgB,EAAE;MAClBsG,eAAe,CAACW,IAAI,CAACnO,2BAA2B,CAAC;;IAGrD,IAAIuN,eAAe,KAAK1L,SAAS,EAAE;MAC/B2L,eAAe,CAACW,IAAI,CAAApN,KAAA,CAApByM,eAAe,EAASD,eAAe;;IAG3C,OAAOC,eAAe;EAC1B,CAAC;EAuID;EACA;EACQ7M,OAAA,CAAA0K,SAAA,CAAAhC,YAAY,GAApB,UAAqBlI,MAAe,EAAE8H,CAAqC,EAAEmF,OAAgB;IAA7F,IAAAtN,KAAA;;IACI;IACA,CAAAiB,EAAA,OAAI,CAACsM,iBAAiB,cAAAtM,EAAA,uBAAAA,EAAA,CAAAU,IAAA,MAAI;IAC1B,IAAI2L,OAAO,KAAKvM,SAAS,IAAIuM,OAAO,GAAG,CAAC,EAAE;MACtC,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAAC9E,UAAU,CAAC;QAAM,OAAAzI,KAAI,CAACuI,YAAY,CAAClI,MAAM,EAAE8H,CAAC,CAAC;MAA5B,CAA4B,EAAEmF,OAAO,CAAC;KACxF,MAAM;MACH,IAAI,IAAI,CAAC/M,KAAK,CAACF,MAAM,IAAI,IAAI,EAAE;QAC3B,IAAI,CAAC6J,QAAQ,CAAC;UAAE7J,MAAM,EAAAA;QAAA,CAAE,CAAC;OAC5B,MAAM;QACH,CAAAwD,EAAA,IAAA3C,EAAA,OAAI,CAACX,KAAK,EAACqL,aAAa,cAAA/H,EAAA,uBAAAA,EAAA,CAAAlC,IAAA,CAAAT,EAAA,EAAGb,MAAM,EAAE8H,CAAC,CAAC;;MAEzC,IAAI,CAAC9H,MAAM,EAAE;QACT;QACA;QACA,CAAAoE,EAAA,IAAAlB,EAAA,OAAI,CAAChD,KAAK,EAAC8G,OAAO,cAAA5C,EAAA,uBAAAA,EAAA,CAAA9C,IAAA,CAAA4B,EAAA,EAAG4E,CAAE,CAAC;;;EAGpC,CAAC;EAEOtI,OAAA,CAAA0K,SAAA,CAAAiB,gBAAgB,GAAxB;;IACI,IAAI,IAAI,CAACjL,KAAK,CAAC0E,SAAS,IAAI,IAAI,CAAC9E,KAAK,CAACE,MAAM,EAAE;MAC3C,IAAMD,aAAa,GAAG,EAAAa,EAAA,OAAI,CAACP,SAAS,CAACgJ,OAAO,cAAAzI,EAAA,uBAAAA,EAAA,CAAE4H,OAAO,CAAC,IAAApC,MAAA,CAAIhI,OAAO,CAACqH,IAAI,CAAE,CAAC,KAAI,IAAI;MACjF,IAAI,CAACoE,QAAQ,CAAC;QAAE9J,aAAa,EAAAA;MAAA,CAAE,CAAC;;EAExC,CAAC;EAEOP,OAAA,CAAA0K,SAAA,CAAAlC,kBAAkB,GAA1B,UAA2BmF,OAAgB;;IACvC,OAAO,CAAAtM,EAAA,IAAAD,EAAA,OAAI,CAAC+H,iBAAiB,EAAE,cAAA/H,EAAA,uBAAAA,EAAA,CAAEkI,QAAQ,CAACqE,OAAO,CAAC,cAAAtM,EAAA,cAAAA,EAAA,GAAI,KAAK;EAC/D,CAAC;EA3lBarB,OAAA,CAAA4N,WAAW,GAAG,GAAAhH,MAAA,CAAG/H,kBAAkB,aAAU;EAE7CmB,OAAA,CAAA6N,YAAY,GAAiB;IACvCR,QAAQ,EAAE,iBAAiB;IAC3BhH,cAAc,EAAE,KAAK;IACrBuE,aAAa,EAAE,KAAK;IACpBlG,QAAQ,EAAE,KAAK;IACfrC,IAAI,EAAE,KAAK;IACXkF,WAAW,EAAE,KAAK;IAClBsB,eAAe,EAAE,GAAG;IACpBF,cAAc,EAAE,GAAG;IACnBzC,gBAAgB,EAAE,IAAI;IACtBvE,eAAe,EAAEhC,sBAAsB,CAACC,KAAK;IAC7C2G,gBAAgB,EAAE,KAAK;IACvBjF,OAAO,EAAE,KAAK;IACdgB,iBAAiB,EAAE,IAAI;IACvB;IACA;IACAyI,mBAAmB,EAAE,UAAU;IAC/BhJ,YAAY,EAAEb,SAAS;IACvBiE,wBAAwB,EAAE,KAAK;IAC/B5C,aAAa,EAAE,MAAM;IACrBuF,kBAAkB,EAAE,GAAG;IACvB1C,SAAS,EAAE;GACd;EAokBL,OAAApF,OAAC;CAAA,CA7lBSrB,qBAAqB;SAFlBqB,OAAO;AAimBpB,SAASsL,IAAIA,CAAA;EACT;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}